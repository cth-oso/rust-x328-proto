/*!
The [`Scanner`] is used to reconstruct X3.28 bus events from byte streams generated by the bus
controller and the nodes. Useful for sniffing a X3.28 bus, or transparently splitting it into segments.
*/

use crate::master::{self, Master, SendData};
use crate::node::Node;
use crate::{addr, param, value, Address, NodeState, Parameter, Value};

/// Decode data from both the master and node channels, and turn it into X3.28 messages
pub struct Scanner {
    node: Node,
    expect: Expect,
}

#[derive(Debug, PartialEq)]
enum Expect {
    Command,
    ReadResponse(Address, Parameter),
    WriteResponse,
}

/// Events generated by transmissions from the bus controller.
#[derive(Debug, Clone, PartialEq)]
pub enum ControllerEvent {
    /// Parameter read request
    Read(Address, Parameter),
    /// Parameter write request
    Write(Address, Parameter, Value),
    /// The bus controller issued a new request without receiving a response to the previous one.
    NodeTimeout,
}

/// Events generated by transmission from a bus node.
#[derive(Debug, Clone)]
pub enum NodeEvent {
    /// Write request response
    Write(Result<(), master::Error>),
    /// Read request response
    Read(Result<Value, master::Error>),
    /// Data was received from a node without a corresponding bus controller request
    UnexpectedTransmission,
}

impl Scanner {
    /// Create a new scanner instance.
    pub fn new() -> Self {
        let node = Node::new(addr(0));
        Self {
            node,
            expect: Expect::Command,
        }
    }

    /// Parse data from the bus controller. The return value is the number of bytes consumed
    /// to generate the returned event. `&data[consumed..]` should be passed in the next call,
    /// together with any newly received data.
    pub fn recv_from_ctrl(&mut self, data: &[u8]) -> (usize, Option<ControllerEvent>) {
        if self.expect != Expect::Command {
            self.expect = Expect::Command;
            return (0, Some(ControllerEvent::NodeTimeout));
        }
        let len = data.len();
        let mut data = data.iter();
        let mut tok = self.node.reset();
        let event = loop {
            tok = match self.node.state(tok) {
                NodeState::ReceiveData(recv) => {
                    let Some(byte) = data.next() else {
                        return (0, None);
                    };
                    recv.receive_data([*byte].as_slice())
                }
                NodeState::SendData(send) => send.data_sent(), // TODO: automatic error responses won't generate an event
                NodeState::ReadParameter(read) => {
                    let (addr, param) = (read.address(), read.parameter());
                    self.expect = Expect::ReadResponse(addr, param);
                    break ControllerEvent::Read(addr, param);
                }
                NodeState::WriteParameter(write) => {
                    let (addr, param, value) = (write.address(), write.parameter(), write.value());
                    self.expect = Expect::WriteResponse;
                    break ControllerEvent::Write(addr, param, value);
                }
            };
        };
        (len - data.as_slice().len(), Some(event))
    }

    /// Parse data from the bus nodes. The return value is the number of bytes consumed
    /// to generate the returned event. `&data[consumed..]` should be passed in the next call,
    /// together with any newly received data.
    pub fn recv_from_node(&mut self, data: &[u8]) -> (usize, Option<NodeEvent>) {
        let mut ctrl = Master::new();
        let len = data.len();
        let mut data = data.iter();
        match &self.expect {
            Expect::Command => return (len, NodeEvent::UnexpectedTransmission.into()),
            Expect::ReadResponse(addr, param) => {
                let mut send = ctrl.read_parameter(*addr, *param);
                let recv = send.data_sent();
                while let Some(byte) = data.next() {
                    if let Some(resp) = recv.receive_data([*byte].as_slice()) {
                        self.expect = Expect::Command;
                        return (len - data.as_slice().len(), NodeEvent::Read(resp).into());
                    }
                }
            }
            Expect::WriteResponse => {
                let mut send = ctrl.write_parameter(addr(1), param(1), value(1));
                let recv = send.data_sent();
                while let Some(byte) = data.next() {
                    if let Some(resp) = recv.receive_data([*byte].as_slice()) {
                        self.expect = Expect::Command;
                        return (len - data.as_slice().len(), NodeEvent::Write(resp).into());
                    }
                }
            }
        }

        return (0, None); // the caller needs to call us with the old data as well as the new
    }
}
